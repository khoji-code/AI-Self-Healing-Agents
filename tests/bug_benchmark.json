{
    "name": "Self-Healing Bug Detection Benchmark",
    "description": "Benchmark suite for testing bug detection and code regeneration",
    "version": "1.0.0",
    "test_cases": [
      {
        "id": "simple_division_by_zero",
        "name": "Simple Division by Zero",
        "difficulty": "easy",
        "description": "Function fails when denominator is zero",
        "bug_type": "division_by_zero",
        "original_code": "def calculate_average(numbers):\n    \"\"\"Calculate average of numbers\"\"\"\n    total = sum(numbers)\n    count = len(numbers)\n    return total / count  # BUG: Division by zero when numbers is empty",
        "test_inputs": [
          {"input": [1, 2, 3, 4, 5], "should_fail": false},
          {"input": [], "should_fail": true},
          {"input": [0], "should_fail": false}
        ],
        "expected_fixes": ["zero_check", "exception_handling"],
        "validation_function": "validate_average_function"
      },
      {
        "id": "null_pointer_simple",
        "name": "Null Pointer Access",
        "difficulty": "easy",
        "description": "Accessing attribute of None object",
        "bug_type": "null_pointer",
        "original_code": "def process_user(user):\n    \"\"\"Process user data\"\"\"\n    return user.name.upper()  # BUG: user could be None",
        "test_inputs": [
          {"input": {"name": "Alice"}, "should_fail": false},
          {"input": None, "should_fail": true},
          {"input": {"name": null}, "should_fail": true}
        ],
        "expected_fixes": ["null_check", "optional_handling"],
        "validation_function": "validate_user_processing"
      },
      {
        "id": "complex_multiple_bugs",
        "name": "Complex Function with Multiple Bugs",
        "difficulty": "hard",
        "description": "Multiple bugs in data processing function",
        "bug_type": "multiple",
        "original_code": "def process_data(data_string, divisor=1):\n    \"\"\"Process data string with various operations\"\"\"\n    \n    # Parse data\n    data = json.loads(data_string)  # BUG 1: No try-catch for invalid JSON\n    \n    # Calculate statistics\n    total = sum(data['values'])\n    average = total / divisor  # BUG 2: Division by zero possible\n    \n    # Transform keys\n    result = {}\n    for key in data.keys():  # BUG 3: keys() returns view, not list in Python 3\n        result[key.upper()] = data[key]\n    \n    # Add metadata\n    result['processed_by'] = current_user.name  # BUG 4: current_user might be None\n    \n    return result",
        "test_inputs": [
          {"input": {"data_string": \"{\\\"values\\\": [1,2,3]}\", \"divisor\": 2}, "should_fail": false},
          {"input": {"data_string": \"invalid json\", \"divisor\": 1}, "should_fail": true},
          {"input": {"data_string": \"{\\\"values\\\": []}\", \"divisor\": 0}, "should_fail": true}
        ],
        "expected_fixes": ["json_parsing_safety", "zero_division_check", "key_iteration_fix", "null_safety"],
        "validation_function": "validate_complex_processing"
      },
      {
        "id": "memory_leak_pattern",
        "name": "Memory Leak Pattern",
        "difficulty": "medium",
        "description": "Potential memory leak in large data processing",
        "bug_type": "memory_leak",
        "original_code": "def process_large_dataset(data):\n    \"\"\"Process large dataset\"\"\"\n    results = []\n    \n    for item in data:\n        # Process each item (memory intensive)\n        processed = heavy_computation(item)\n        results.append(processed)\n        \n        # BUG: results list keeps growing, no cleanup\n        \n    return results",
        "test_inputs": [
          {"input": [1, 2, 3, 4, 5], "should_fail": false, "note": "Small data works"},
          {"input": list(range(1000000)), "should_fail": true, "note": "Large data causes memory issues"}
        ],
        "expected_fixes": ["chunked_processing", "memory_cleanup", "generator_use"],
        "validation_function": "validate_memory_usage"
      }
    ],
    "scoring": {
      "detection_weight": 0.4,
      "fix_weight": 0.4,
      "performance_weight": 0.2,
      "difficulty_multiplier": {
        "easy": 1.0,
        "medium": 1.5,
        "hard": 2.0
      }
    }
  }